---
language: "he"
title: "Resource Optimization - איך כל הגורמים משפיעים בפועל על Latency ו-TPS"
categories:
  - "למידת מכונה"
  - "חומרה"
tags:
  - "אופטימיזציה"
  - "NUMA"
  - "הסקה"
series: "אופטימיזציה של חומרת הסקה"
previousPost: "7-resource-division"
nextPost: "9-series-summary"
slug: "8-resource-optimization"
---


# Resource Optimization - איך כל הגורמים משפיעים בפועל על Latency ו-TPS

בכל מערכת inference, כל שינוי קטן - בליבות, בזיכרון, או בדרך החלוקה של המשאבים - משפיע על שני מדדים עיקריים:

- **Latency (זמן תגובה)** - כמה זמן לוקח לבקשה אחת להסתיים.
- **TPS (כמות תחזיות לשנייה)** - כמה תחזיות המערכת מצליחה לעבד בשנייה.

כדי לשפר אחד, לעיתים מקריבים את השני. להבין את האיזון הזה - זו המהות של אופטימיזציה אמיתית.

## איך NUMA, חלוקת ליבות ו-Resource Division מתחברים יחד

- **NUMA (Non-Uniform Memory Access)** -
  כשמודל ניגש לזיכרון "מרוחק", הוא מבזבז זמן על תקשורת בין מעבדים.
  התוצאה: עלייה ב-latency גם אם כוח העיבוד נשאר זהה.

- **חלוקת ליבות (Thread Affinity)** -
  כשthreads נודדים בין ליבות, הם מאבדים את ה-cache המקומי,
  מה שמוריד יעילות ומוסיף עיכובים מיותרים.
  שמירה על affinity משפרת את היציבות ומונעת "קפיצות" ב-latency.

- **Resource Division (חלוקת משאבים בין מודלים)** -
  אם שני מודלים מתחרים על אותם משאבים, כל אחד מהם יקבל פחות מה-CPU או הזיכרון הדרוש.
  זה מעלה latency ויכול להוריד throughput דרמטית.
  ניהול חכם (Isolation או Load Balancing נכון) מחזיר את האיזון.

## איך למדוד נכון ולזהות את ה-Bottlenecks

מדידה שטחית של זמן ריצה לא מספרת את כל הסיפור.
כדי להבין איפה צוואר הבקבוק, צריך לבחון כמה שכבות:

- **CPU Utilization** - האם כל הליבות עסוקות באמת או שחלק “מבזבזות זמן” בהמתנה?
- **Memory Bandwidth** - האם יש עומס גישה בין NUMA nodes?
- **Thread Scheduling** - האם threads קופצים בין ליבות?
- **Latency Distribution** - לא רק ממוצע, אלא גם סטיית תקן: חוסר יציבות הוא סימן לחלוקה לא נכונה.

## עקרונות לניסוי ובדיקת אופטימיזציה

- שנה רק פרמטר אחד בכל ניסוי - אחרת אי אפשר לדעת מה באמת השפיע.
- מדוד לאורך זמן - מערכות inference מושפעות גם מתנודות עומס.
- עקוב אחרי מדדים עקביים (TPS, P99 latency, CPU usage).
- השווה תצורות NUMA / affinity / isolation תחת אותם תנאים בדיוק.
- תעד כל שינוי - גם אופטימיזציה קטנה עלולה להיראות הפוכה כשלא נבדקת בהקשר הנכון.

## בשורה התחתונה

שום רכיב - NUMA, ליבות, או משאבים - לא עומד בפני עצמו.
רק כשמבינים איך כולם מתקשרים זה עם זה, אפשר להגיע לאופטימיזציה אמיתית:
מערכת שבה כל חישוב מנוצל, כל thread נמצא במקום הנכון,
וכל תחזית יוצאת בזמן - בלי לבזבז אף מיקרו-שנייה.