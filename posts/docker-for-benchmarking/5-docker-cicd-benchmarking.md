---
language: "he"
title: "איך משלבים Docker ב-CI/CD להרצת Inference Benchmarking אוטומטי"
categories:
  - "תשתיות"
tags:
  - "Docker"
  - "CI/CD"
series: "Docker למדידת ביצועים"
previousPost: "4-docker-inference-benchmarking"
slug: "5-docker-cicd-benchmarking"
---


# איך משלבים Docker ב-CI/CD להרצת Inference Benchmarking אוטומטי

בפוסטים הקודמים דיברנו על איך Docker מבטיח סביבת ניסוי עקבית ואמינה.
אבל בעולם אמיתי - אנחנו לא רוצים להריץ benchmark ידנית בכל פעם שמודל או מנוע משתנים.
כאן נכנס השלב הבא: אוטומציה מלאה באמצעות CI/CD.

## מה זה בעצם אומר?

CI/CD (Continuous Integration / Continuous Deployment)
הוא תהליך שבו כל שינוי בקוד (למשל מודל מעודכן או גרסת inference חדשה)
מפעיל שרשרת בדיקות אוטומטית - כולל benchmarking.

המטרה: לדעת מיידית אם שינוי שיפר או פגע בביצועים.

## איך Docker משתלב בתהליך הזה

- **Docker Image כיחידת עבודה קבועה**
  כל הרצת benchmark נעשית מתוך אותו image בדיוק - עם אותן ספריות, אותן גרסאות CUDA וכו’.
  כך מבטיחים שהמדידה משווה תפוחים לתפוחים.

- **Pipeline שמריץ את הקונטיינר**
  בכל commit או שינוי במודל, ה-CI (למשל Jenkins, GitHub Actions או GitLab CI)
  מושך את ה-Docker image ומריץ בו את הבדיקות.

- **מדידת ביצועים ואיסוף תוצאות**
  הסקריפטים בתוך הקונטיינר מודדים זמני תגובה, צריכת זיכרון ו-throughput.
  התוצאות נשלחות אוטומטית ללוג או ל-dashboard ייעודי.

## דוגמה פשוטה ל-Workflow טיפוסי

1. שינוי חדש במודל נכנס ל-main branch.
2. ה-CI מפעיל container עם סביבת הבדיקה.
3. מתבצע inference benchmark על סט נתונים קבוע.
4. התוצאות מושוות לגרסה הקודמת.
5. אם יש ירידה בביצועים - מתקבלת התראה אוטומטית.

## למה זה חשוב

- **עקביות מלאה** - כל ריצה זהה לסביבה הקודמת.
- **תגובה מהירה** - כל שינוי נבדק אוטומטית.
- **מעקב היסטורי** - קל לראות איך כל שינוי השפיע על הביצועים לאורך זמן.

## לסיכום

שילוב Docker בתוך CI/CD הוא הדרך להפוך benchmarking למשהו שקורה לבד,
בצורה מדויקת, עקבית ומהירה.
במקום “להריץ כשיש זמן”, הוא הופך לחלק מה-DNA של תהליך הפיתוח -
ככה יודעים תמיד שהמודל באמת מתקדם, ולא רק משתנה.
